# geektime_arch_training_camp
极客时间架构师训练营第08周作业

#作业一（至少完成一项）：
## 1、有两个单向链表（链表长度分别为 m，n），这两个单向链表有可能在某个元素合并，也可能不合并，如下图所示的这样。现在给定两个链表的头指针，在不修改链表的情况下，如何快速地判断这两个链表是否合并？如果合并，找到合并的元素，也就是图中的 x 元素。
请用代码（或伪代码）描述算法，并给出时间复杂度。参考网上的解法：
（1）创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。

（2）当 pA到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。

（3）若在某一时刻 pA 和 pB相遇，则pApB 为相交结点。

（4）想弄清楚为什么这样可行, 可以考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。 由于 B.length (=4) < A.length (=6)，pB 比 pA 少经过 22 个结点，会先到达尾部。将 pB重定向到 A 的头结点，pA重定向到 B 的头结点后，pB要比 pA多走 2 个结点。因此，它们会同时到达交点。

如果两个链表存在相交，它们末尾的结点必然相同。因此当 pApA/pBpB 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。

复杂度分析

时间复杂度 : O(m+n)O(m+n)。
空间复杂度 : O(1)O(1)。

    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)
    {
        if (NULL == headA || NULL == headB)
        {
            return NULL;
        }

        ListNode *pA = headA;
        ListNode *pB = headB;

        while (pA != pB)
        {
            pA = (pA == NULL ? headB : pA->next);
            pB = (pB == NULL ? headA : pB->next);
        }

        return pA;
    }


## 2、请画出 DataNode 服务器节点宕机的时候，HDFS 的处理过程时序图。

# 作业二：根据当周学习情况，完成一篇学习总结
本周的课程主要讲的是系统底层的基础原理，包括文件与硬盘IO、常见数据结构、经典算法、网络通信原理与网络优化等等。更加系统化的学习了系统底层的相关知识点，更加夯实了基础理论知识。